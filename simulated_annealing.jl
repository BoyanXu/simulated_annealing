using Test
using LinearAlgebra
using Random
using Winston
include("lowerbounds.jl")


function check_square(m, msg)
	n = size(m, 1)
	if n != size(m, 2)
		error(msg)
	end
	return n
end

function legal_circuit(circuit)
	n = length(circuit) - 1
	return circuit[1] == circuit[end] && sort(circuit[1:(end-1)]) == 1:n
end

function testpathvalidity(path, iscycle)
	if iscycle
		@test path[1] == path[end]
	end
	n = iscycle ? length(path) - 1 : length(path)
	@test sort(unique(path)) == collect(1:n)
end

function pathcost(distmat::Matrix{T},path::AbstractArray{S},
				  manWeight, goodWeight, capacities,
                  lb::Int = 1, ub::Int = length(path)) where {T<:Real, S<:Integer}
				  # distmat: the distance matrix generated by  generate_planar_distmat() in runtests.jl
				  # path: the order of visiting
	cost = zero(T)
	curWeight = manWeight + goodWeight
	for i in lb:(ub - 1)
		curWeight = (curWeight - capacities[i] >= manWeight) ? curWeight - capacities[i] : manWeight
		@inbounds cost += distmat[path[i], path[i+1]] * curWeight
		# @inbounds elinimates the bound checking to improve performance
	end
	return cost
end

function pathcost_rev(distmat::Matrix{T}, path::AbstractArray{S},
					  manWeight, goodWeight, capacities,
                      revLow::Int, revHigh::Int) where {T<:Real, S<:Integer}
	cost = zero(T)
	curWeight = manWeight + goodWeight
	reverse!(path, revLow, revHigh)
	# println(path)
	for i in 1:(length(path) - 1)
		curWeight = (curWeight - capacities[i] >= manWeight) ? curWeight - capacities[i] : manWeight
		@inbounds cost += distmat[path[i], path[i+1]] * curWeight
	end
	return cost
end


function simulated_annealing(distmat::Matrix{T} where {T<:Real},
							 capacities::Array{T} where {T<:Real},
							 manWeight, goodWeight;
                             steps = 50*length(distmat),
							 num_starts = 1,
							 init_temp = exp(8), final_temp = exp(-6.5),
							 init_path::Union{Vector{Int}, Nothing} = nothing)

	# check inputs
	n = check_square(distmat, "Must pass a square distance matrix to simulated_annealing.")

	# cooling rate: we multiply by a constant mult each step
	cool_rate = (final_temp / init_temp)^(1 / (steps - 1))

	# do SA with a single starting path
	function sahelper!(path)
		temp = init_temp / cool_rate # divide by cool_rate so when we first multiply we get init_temp
		n = size(distmat, 1)
		cost_cur = pathcost(distmat, path, manWeight, goodWeight, capacities)  # current state's energy

		for i in 1:steps
			temp *= cool_rate

			# take a step
			# keep first and last cities fixed
			first, last = rand(2:n), rand(2:n)
			if first > last
				first, last = last, first # to be swapped
			end
			cost_other = pathcost_rev(distmat, path, manWeight, goodWeight, capacities, first, last)  # neighbour state's energy
			@fastmath accept = cost_other < cost_cur ? true : rand() < exp((cost_cur - cost_other) / temp)
			# should we accept?
			if accept
				reverse!(path, first, last)
				cost_cur = cost_other
			end
		end

		return path, cost_cur
	end

	# unpack the initial path
	if init_path == nothing
		randstart = true
		path = randpath(n)
	else
		if !legal_circuit(init_path)
			error("The init_path passed to simulated_annealing must be a legal circuit.")
		end
		randstart = false
		path = init_path
	end
	cost = pathcost(distmat, path, manWeight, goodWeight, capacities) # The emergy of currrent state

	for _ in 1:num_starts
		path_this_start = randstart ? randpath(n) : deepcopy(init_path) # generate new
		otherpath, othercost = sahelper!(path_this_start)
		if othercost < cost
			cost = othercost
			path = otherpath
		end
	end

	return path, cost
end

function randpath(n)
	path = 1:n |> collect |> shuffle
	push!(path, path[1]) # loop
	return path
end


function generate_planar_distmat(n)
	pts = rand(2, n)
	dm = [norm(pts[:,i] - pts[:,j]) for i in 1:n, j in 1:n]
	return dm, pts
end

function generate_city_capacity(n , weight_of_good)
	base = weight_of_good / n
	city_capacities = [0 for i in 1:n]
	for i = 1:n
		city_capacities[i] = rand(floor(Int, base*0.6):floor(Int, base*1.4))
	end
	return city_capacities
end

function test_simulated_annealing()
	n = 3
	manWeight = 100
	goodWeight = manWeight*3
	dm, pts = generate_planar_distmat(n)
	pts = transpose(pts)

	dm = ones(3, 3)

	println("The pts are: ")
	println(pts)
	println("The distance matrix is: ")
	println(dm)

	capacities = [100 300 300]#generate_city_capacity(n, goodWeight)
	# single start
	path, cost = simulated_annealing(dm, capacities , manWeight, goodWeight)
	println("The solution path is: ", path)
	println("The cost is: ", cost)
	@test cost > 0
	testpathvalidity(path, true) # closed path
	# multi-start
	n = 8
	dm, pts = generate_planar_distmat(n)
	capacities = generate_city_capacity(n, goodWeight)
	path, cost = simulated_annealing(dm, capacities ,  manWeight, goodWeight, num_starts = 3)
	@test cost > 0
	testpathvalidity(path, true) # also closed
	# given init path
	init_path = collect(1:8)
	push!(init_path, 1)
	reverse!(init_path, 2, 6)
	path, cost = simulated_annealing(dm, capacities,  manWeight, goodWeight, init_path = init_path)
	@test cost > lowerbound(dm)
	testpathvalidity(path, true) # still closed
end

test_simulated_annealing()
